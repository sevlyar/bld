bld - Simple Make System

# Руководство

Утилита предназначена для автоматизации операций преобразования одних 
файлов в другие с помощью сценария (таких как построение исполняемого файла 
из исходных и т.п.). Сценарий является json-файлом, он условно состоит из 
секций, которые есть ни что иное как поля главного объекта.

В сценарии указывается последовательность операций, шагов, которые 
необходимо выполнить, чтобы преобразовать одни файлы в другие. При этом
указываются зависимости между шагами, т.к. в текущем шаге может
использоваться результат, полученный на предыдущем. Неизвестно в какой
последовательности будут выполнены операции, между которыми нет 
зависимостей, более того, они могут выполняться параллельно.

Операция представляет из себя один или несколько вызовов другой утилиты
с указанными параметрами. При описании параметров вызова утилит возможно 
использовать макроподстановку: встроенные и пользовательские 
макроопределения. Операция применяется к группе файлов, к каждому в 
отдельности или ко всем сразу.

Исходные файлы описываются директориями поиска и маской (регулярным 
выражением) имени. Действие связывается с файлом через макрос **$(@)**
в параметрах вызова утилиты, на место которого подставляется имя файла
(или имена группы файлов).

+ [Директории](#Директории)
+ [Аргументы командной строки](#Аргументы)
+ [Сценарий](#Сценарий)
    + [Комбинирование сценариев](#Комбинирование)
    + [Макросы](#Макросы)
        + [Переменные среды](#Переменные)
    + [Операции](#Операции)
+ [Кеширование](#Кэширование)


## Директории

При исполнении сценария утилита использует две директории: рабочую и 
корневую директория проекта (root). Сценарий имеет возможность ссылаться
на эти директории через макроподстановку параметров: **$(..)** - корневая, 
**$(.)** - рабочая. Хорошим тоном будет если сценарий написан таким образом,
что он не модифицирует и не создает файлы в директориях проекта, а 
использует для этого рабочую директорию. При вызове утилиты bld есть
возможность указать рабочую и корневую директории через параметры.


## Аргументы командной строки

`bld <scenario> <root-dir>`

Утилита имеет два аргумента:
+ *scenario* - путь к сценарию без расширения относительно корневой директории 
проекта, может быть опущен вместе с *root-dir*, если опущен, то ищется файл
**build.json**;
+ *root-dir* - корневая директория проекта, если опущен - считается что равен
`./..`.


## Сценарий

Сценарий является json-валидным файлом и имеет следующую структуру:

```json
{
    "combine": [ "include.json", ... ],

  	"defs": { 
        "MACRO-NAME": ["macro-value", ... ], 
        ... 
    },

    "ops": [
        {
        "name": "operation-name",
        "descr": "operation description",

        "deps": ["some-operation-name", ... ],

        "sources": "sources-pattern",
        "dirs": ["dir-path", ...],
        "group": true,

        "tool": "tool-name",
        "args": [
            "arg",
            ...
        ]
        },
        ...
    ]
}
```


### Комбинирование сценариев

Файлы, указанные в поле **"combine"** комбинируются с данным сценарием, это
похоже на включение файлов, только происходит не на уровне текста сценария, а
на уровне данных, описанных в сценарии. Комбинирование - это первая операция, 
которая происходит со сценарием после его загрузки.

Списки макроопределений из комбинируемых сценариев объеденяются в один, если 
встречаются макросы с одинаковыми именами, тогда объединяются их значения.

Списки операций также объединяются. Совпадение имен операций из объединяемых
списков недопустимо - в таком случае выдается предупреждение и работа утилиты
завершается.


### Макроопределения и макроподстановка

Макросы используются для упрощения настройки операций, сокращения размера
сценария и связи файлов с действиями.

Макросы указываются в поле **"defs"**. При определении макроса указывается
его имя и множество значений:
`"defs":	{ "MACRO-NAME": ["value1", "value2", ...] }`

Множество значений может быть пустым, состоять из одного значения или
нескольких. В имени макроса допустимо использование алфавитно-цифровых
символов, регистр различается.

Макровызов имеет синтаксис `$(MACRO-NAME)"`. Макровызовы 
допустимо использовать при указании значений некоторых параметров (будет
конкретно указано ниже).

Перед использованием, значение параметра будет проанализировано и на место 
макровызова будет подставлено его значение. Если же количество значений
макроса больше одного, тогда значение параметра будет размножено и
подстановка будет произведена по одному разу для каждого значения макроса.
Если же множество пустое, тогда аргумент с таким макровызовом будет
исключен из списка.

Также существует набор встроенных макросов:
* `$(.)`  - рабочая директория;
* `$(..)` - корневая директория;
* `$(@)`  - имя обрабатываемого файла (имена файлов при групповой операции);
* `$(#)`  - GUID (допустимо использовать для имени файла).

Возможно применение при макроподстановке модификатора '/', он указывает что
следует трактовать значения макроса как путь к файлу (директории) и
подставлять только имя файла (директории). Модификатор указывается перед именем
макроса: `$(/SOME-PATH)`.

При определении значений макросов также допустимо использовать 
макроподстановку. После загрузки макроопределений происходит их 
"разворачивание" - подстановка в значения макроопределений. Макросы `$(@)` и
`$(#)` не "разворачиваются", подстановка их значений происходит 
непосредственно перед каждым вызовом операции (вызовом другой утилиты).

Если в значении указано несколько макроподстановок, тогда произойдет
фактически перемножение множеств значений макросов и получится множество
параметров, являющееся всевозможным сочетанием значений макросов. Допустимо 
также использование вложенных макросов, таких как:
	`["$($(MACRO-NAMES)-DIRS)"]`
Такие макросы будут разворачиваться изнутри-наружу. Например, если 
значением макроса `$(MACRO-NAME)` является `["SRC", "INCL"]`, тогда
сначала произойдет подстановка внутреннего макроса и получим: 
	`["$(SRC-DIRS)", "$(INCL-DIRS)"]`
Далее будет произведена подстановка значений полученных макросов.
Подстановка будет производится до тех пор, пока не будут развернуты все 
макроподстановки, поэтому надо быть осторожными с ними, т.к. неаккуратное 
использование макросов может привести к зацикливанию и зависанию утилиты.
В данный момент это никак не контролируется.


#### Переменные среды

Допустимо также использовать макросподстановку переменных среды. 
Макроподстановка переменных среды отличается от макроподстановки встроенных
переменных использованием фигурных скобок вместо круглых: `${VAR-NAME}`.
С переменными среды нельзя использовать модификаторы. Если указанная 
переменная не существует, то **ее вызов заменяется пустой строкой**.


### Операции

Операция, с одной стороны, описывает вызов (или группу вызовов) другой утилиты 
или программы и передаваемые ей аргументы, с другой стороны исходные файлы и
где их искать. Для связи исходных файлов с утилитой используется 
макроподстановка в аргументы вызова утилиты.

Операции могут быть групповыми и негрупповыми. Для групповых операций делается 
один вызов утилиты и в аргументы подставляются имена сразу всех подходящих 
исходных файлов.

Также для операции указываются зависимости, от каких операций она зависит, для
указания порядка выполнения. Операция начнет выполнятся только тогда, когда
будут закончены все операции, от которых она зависит.

Операции указываются в поле **"ops"**, каждая операция имеет следующие поля:

+ **name** - имя операции, правила такие же как и для имени макроса, может 
опускаться, если не требуется ссылаться на операцию;
+ **descr** - описание операции, выводится при работе утилиты, может опускаться;
+ **deps** - список операций, от которых зависит данная, может опускаться,
если нет зависимостей;
+ **sources** - список регулярных выражений, описывающих имена 
файлов-источников, могут использоваться макросы, кроме `$(@)` и `$(#)`;
+ **dirs** - директории поиска файлов-источников, могут использоваться макросы,
кроме `$(@)` и `$(#)`;
+ **group** - true, если операция групповая, по умолчанию false, может 
опускаться;
+ **tool** - имя утилиты;
+ **args** - список аргументов вызова утилиты, могут использоваться любые 
макросы.


## Кэширование

Для уменьшения количества операций преобразования файлов и ускорения
перестроения проекта, утилита использует механизмы кэширования и 
определения связей между файлами. Предполагается, что если файл не 
изменился со времени последнего вызова утилиты, тогда незачем снова 
запускать его преобразование. Но тут есть один "тонкий момент", дело в том, 
что некоторые исходные файлы могут неявно зависеть от других. Например 
препроцессор языков C/C++ позволяет делать включения заголовочных файлов, 
тогда возможна ситуация, когда исходный файл не был изменен со времени 
последнего запуска, а заголовочный файл был изменен, тогда результат 
построения исходного файла скорее всего будет отличаться от предыдущего
построения. Для определения таких ситуаций используется механизм определения
связей.
